package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/shurcooL/graphql/ident"
	"golang.org/x/oauth2"
)

func main() {
	transport := &oauth2.Transport{
		Source: oauth2.StaticTokenSource(&oauth2.Token{
			AccessToken: os.Getenv("GITHUB_TOKEN"),
		}),
		Base: http.DefaultTransport,
	}
	client := &http.Client{Transport: transport}
	resp, err := client.Get("https://api.github.com/graphql")
	if err != nil {
		log.Fatal(err)
	}
	respBodyBytes, err := io.ReadAll(resp.Body)
	_ = resp.Body.Close()
	if err != nil {
		log.Fatal(err)
	}
	var respBody struct {
		Data struct {
			Schema struct {
				MutationType     any     `json:"mutationType"`
				SubscriptionType any     `json:"subscriptionType"`
				Types            []*Type `json:"types"`
				QueryType        any     `json:"queryType"`
				Directives       []any   `json:"directives"`
			} `json:"__schema"`
		} `json:"data"`
	}
	decoder := json.NewDecoder(bytes.NewReader(respBodyBytes))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&respBody)
	if err != nil {
		log.Fatal(err)
	}

	typeByName := make(map[string]*Type, len(respBody.Data.Schema.Types))
	for _, t := range respBody.Data.Schema.Types {
		_, ok := typeByName[t.Name]
		if ok {
			log.Fatalf("two types named %#v\n", t.Name)
		}
		typeByName[t.Name] = t
	}
	toGoTypeName := func(n string) string {
		return ident.ParseLowerCamelCase(n).ToMixedCaps()
	}
	toGoType := func(t *TypeRef) string {
		invalidTypeRefErr := func() error {
			tJSON, _ := json.Marshal(t)
			return fmt.Errorf("invalid type ref %s", string(tJSON))
		}
		prefix := "*"
		if t.Kind == "NON_NULL" {
			if t.OfType == nil || t.Name != nil {
				panic(invalidTypeRefErr())
			}
			t = t.OfType
			prefix = ""
		}
		if t.Kind == "LIST" {
			if t.OfType == nil || t.Name != nil {
				panic(invalidTypeRefErr())
			}
			t = t.OfType
			prefix += "[]"
			if t.Kind == "NON_NULL" {
				if t.OfType == nil || t.Name != nil {
					panic(invalidTypeRefErr())
				}
				t = t.OfType
			} else {
				prefix += "*"
			}
		}
		switch t.Kind {
		case "SCALAR":
			if t.Name == nil || t.OfType != nil {
				panic(invalidTypeRefErr())
			}
			switch *t.Name {
			case "ID", "GitObjectID", "URI", "DateTime", "Base64String", "Date":
				return prefix + *t.Name
			case "Boolean":
				return prefix + "bool"
			case "String":
				return prefix + "string"
			case "Int":
				return prefix + "int"
			case "Float":
				return prefix + "float64"
			}
		case "ENUM", "INPUT_OBJECT":
			if t.Name == nil || t.OfType != nil {
				panic(invalidTypeRefErr())
			}
			if _, ok := typeByName[*t.Name]; !ok {
				panic(fmt.Errorf("dangling type ref %s %s", t.Kind, *t.Name))
			}
			return prefix + toGoTypeName(*t.Name)
		}
		tJSON, _ := json.Marshal(t)
		panic(fmt.Errorf("converting type ref to go is not implemented: %s", string(tJSON)))
	}

	var typesToOutput []*Type
	for _, t := range typeByName {
		if !strings.HasPrefix(t.Name, "__") && (t.Kind == "INPUT_OBJECT" || t.Kind == "ENUM") {
			typesToOutput = append(typesToOutput, t)
		}
	}
	sort.Slice(typesToOutput, func(i, j int) bool {
		return typesToOutput[i].Name < typesToOutput[j].Name
	})
	buf := new(bytes.Buffer)
	printfIndent := 0
	printf := func(format string, args ...any) {
		fmt.Fprintf(buf, strings.Repeat("\t", printfIndent)+format, args...)
	}
	multiLineComment := func(text string) {
		text = strings.TrimSpace(text)
		lines := strings.Split(text, "\n")
		for _, line := range lines {
			printf("// %s\n", line)
		}
	}
	printf("package githubv4\n\n")
	for _, t := range typesToOutput {
		descrTrimmed := strings.TrimSpace(t.Description)
		descrFirstWord := descrTrimmed
		if i := strings.IndexAny(descrTrimmed, " .;,"); i >= 0 {
			descrFirstWord = descrFirstWord[:i]
		}
		goTypeName := toGoTypeName(t.Name)
		var comment string
		switch {
		case strings.EqualFold(descrFirstWord, "autogenerated"):
			comment = goTypeName + " is an autogenerated" + descrTrimmed[len(descrFirstWord):]
		default:
			descrFirstWordLower := firstLetterToLower(descrFirstWord)
			comment = goTypeName + " represents " + descrFirstWordLower + descrTrimmed[len(descrFirstWord):]
		}
		if !strings.HasSuffix(comment, ".") {
			comment += "."
		}
		multiLineComment(comment)
		switch t.Kind {
		case "INPUT_OBJECT":
			printf("type %s struct {\n", goTypeName)
			printfIndent++
			for _, inputField := range t.InputFields {
				goFieldName := toGoTypeName(inputField.Name)
				descrTrimmed := strings.TrimSpace(inputField.Description)
				if !strings.HasSuffix(descrTrimmed, ".") {
					descrTrimmed += "."
				}
				multiLineComment(descrTrimmed)
				goType := toGoType(&inputField.Type)
				printf("%s %s %#v\n", goFieldName, goType, fmt.Sprintf(`json:%#v`, inputField.Name))
			}
			printfIndent--
			printf("}\n\n")
			printf("// Compile-time assertion that %s implements the Input interface.\n", goTypeName)
			printf("var _ Input = (*%s)(nil)\n\n", goTypeName)
			printf("// isInput implements the Input interface.\n")
			printf("func (%s) isInput() {}\n\n", goTypeName)
		case "ENUM":
			printf("type %s string\n\n", goTypeName)
			printf("const (\n")
			printfIndent++
			for _, enumValue := range t.EnumValues {
				constName := goTypeName + ident.ParseScreamingSnakeCase(enumValue.Name).ToMixedCaps()
				comment := constName + ". " + strings.TrimSpace(enumValue.Description)
				if !strings.HasSuffix(comment, ".") {
					comment += "."
				}
				multiLineComment(comment)
				printf("%s %s = %#v\n", constName, goTypeName, enumValue.Name)
			}
			printfIndent--
			printf(")\n\n")
		}
	}
	if err := os.WriteFile("../gen.go", buf.Bytes(), 0600); err != nil {
		log.Fatal(err)
	}
	cmd := exec.Command("gofmt", "-w", "../gen.go")
	_, err = cmd.CombinedOutput()
	if err != nil {
		log.Fatal(err)
	}
}

type Type struct {
	Description string       `json:"description"`
	EnumValues  []EnumValue  `json:"enumValues"`
	Fields      []Field      `json:"fields"`
	InputFields []InputField `json:"inputFields"`

	// List of observed values: INPUT_OBJECT, OBJECT, UNION, INTERFACE
	// Not all possible observed values are given.
	Kind       string    `json:"kind"`
	Name       string    `json:"name"`
	Interfaces []TypeRef `json:"interfaces"`

	// PossibleTypes is set when Kind is UNION.
	PossibleTypes []TypeRef `json:"possibleTypes"`
}

type InputField struct {
	DefaultValue any     `json:"defaultValue"`
	Description  string  `json:"description"`
	Name         string  `json:"name"`
	Type         TypeRef `json:"type"`
}

type Field struct {
	Args         []InputField `json:"args"`
	Description  string       `json:"description"`
	IsDeprecated bool         `json:"isDeprecated"`
	Deprecated   string       `json:"deprecationReason"`
	Name         string       `json:"name"`
	Type         TypeRef      `json:"type"`
}

type TypeRef struct {
	Kind   string   `json:"kind"`
	Name   *string  `json:"name"`
	OfType *TypeRef `json:"ofType"`
}

type EnumValue struct {
	Description  string `json:"description"`
	IsDeprecated bool   `json:"isDeprecated"`
	Deprecated   string `json:"deprecationReason"`
	Name         string `json:"name"`
}

func firstLetterToLower(s string) string {
	r, size := utf8.DecodeRuneInString(s)
	if r != utf8.RuneError {
		return string(unicode.ToLower(r)) + s[size:]
	}
	if size == 0 {
		return ""
	}
	panic(fmt.Errorf("invalid UTF8: %#v", s))
}
